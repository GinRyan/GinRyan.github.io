<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Go笔记4-Go面向对象编程1 | 梁工春日的忧郁 | 孤星独吟</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  <meta name="keywords" content="Go">
  <meta name="description" content="面向对象的特性提到面向对象，我们第一反应会想到C++，Java，Python，C#一众语言。在学习时我们也会多多少少地去类比这些传统OOP语言。Go语言相较之下设计非常简洁而又优雅。它在语言层面上做了巨大的革新，放弃了传统OOP当中耳熟能详的概念，比如继承、虚函数、构造函数、析构函数、隐藏this指针等。整个类型系统通过接口自动变形来串联起来，更加简洁。这也可以侧面看出来为什么称Go是”更好的C语">
<meta property="og:type" content="article">
<meta property="og:title" content="Go笔记4-Go面向对象编程1">
<meta property="og:url" content="http://yoursite.com/2016/05/24/Go语言笔记4面向对象编程/index.html">
<meta property="og:site_name" content="梁工春日的忧郁">
<meta property="og:description" content="面向对象的特性提到面向对象，我们第一反应会想到C++，Java，Python，C#一众语言。在学习时我们也会多多少少地去类比这些传统OOP语言。Go语言相较之下设计非常简洁而又优雅。它在语言层面上做了巨大的革新，放弃了传统OOP当中耳熟能详的概念，比如继承、虚函数、构造函数、析构函数、隐藏this指针等。整个类型系统通过接口自动变形来串联起来，更加简洁。这也可以侧面看出来为什么称Go是”更好的C语">
<meta property="og:updated_time" content="2016-06-04T03:06:53.249Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Go笔记4-Go面向对象编程1">
<meta name="twitter:description" content="面向对象的特性提到面向对象，我们第一反应会想到C++，Java，Python，C#一众语言。在学习时我们也会多多少少地去类比这些传统OOP语言。Go语言相较之下设计非常简洁而又优雅。它在语言层面上做了巨大的革新，放弃了传统OOP当中耳熟能详的概念，比如继承、虚函数、构造函数、析构函数、隐藏this指针等。整个类型系统通过接口自动变形来串联起来，更加简洁。这也可以侧面看出来为什么称Go是”更好的C语">
  
    <link rel="alternative" href="/atom.xml" title="梁工春日的忧郁" type="application/atom+xml">
  
  <link rel="shortcut icon" href="/favicon.ico">
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="loading" class="active"></div>

  <nav id="menu" class="hide" >
   <div class="inner">
  <a href="javascript:;" class="header-icon waves-circle-light" id="menu-off">
      <i class="icon icon-lg icon-close"></i>
  </a>
  <div class="brand-wrap">
    <div class="brand">
      <a href="./" class="avatar"><img src="/img/logo.jpg"></a>
      <hgroup class="introduce">
        <h5 class="nickname">Xelloss</h5>
        <a href="mailto:undefined" title="gino3@qq.com" class="mail">gino3@qq.com</a>
      </hgroup>
    </div>
  </div>
  <ul class="nav">
    
        <li class="waves-block">
          <a href="/"  >
            <i class="icon icon-lg icon-home"></i>Home
          </a>
        </li>
    
        <li class="waves-block">
          <a href="/archives"  >
            <i class="icon icon-lg icon-archives"></i>Archives
          </a>
        </li>
    
        <li class="waves-block">
          <a href="/tags"  >
            <i class="icon icon-lg icon-tags"></i>Tags
          </a>
        </li>
    
        <li class="waves-block">
          <a href="https://github.com/GinRyan" target="_blank" >
            <i class="icon icon-lg icon-github"></i>Github
          </a>
        </li>
    
  </ul>

  <footer class="footer">
  <p><a rel="license" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Creative Commons License" style="border-width:0;vertical-align:middle;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAAAPCAMAAABEF7i9AAAAllBMVEUAAAD///+rsapERER3d3eIiIjMzMzu7u4iIiKUmZO6v7rKzsoODg4RERFVVVUNDQ0NDg0PEA8zMzNLTEtbXltmZmZydnF9gn2AgICPkI+ZmZmqqqq7u7vFxsXIzMgNDQwZGRkgICAhISEkJSMnKCcuMC4xMzE5Ozk7PTtBQkFCQkJDQ0Nna2eGhoaHh4ezuLLGysbd3d1wVGpAAAAA4UlEQVR42q2T1xqCMAyFk7QsBQeKA9x7j/d/OSm22CpX0nzcpA1/T05aAOuBVkMAScQFHLnEwoCo2f1TnQIGoVMewjZEjVFN4GH1Ue1Cn2jWqwfsOOj6wDwGvotsl/c8lv7KIq1eLOsT0HMFHMIE/RZyHnlphryT9zyV+8WH5e8yQw3wnQvgAFxPTKUVi555SHR/lOfLMgVTeDlSfN+TaoUsiTyeIm+bCkHvCA2FUKG48LDtYBZBknsYP/G8NTw0gaaHyuQf4H5pecrB/FYCT2sL9zAfy1Xyjou6L8X2W7YcLyBZCRtnq/zfAAAAAElFTkSuQmCC" /></a></p>
  <p>梁工春日的忧郁 &copy; 2016</p>
  <p>Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme
  <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a></p>
  <a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-2x icon-rss-square"></i></a>
</footer>

</div>

  </nav>
  <main id="main">
    <header class="header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-circle-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">Go笔记4-Go面向对象编程1</div>
        <a href="javascript:;" class="header-icon waves-circle-light" id="menu-share">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
    </div>
</header>
<header class="content-header">
  <div class="container">
    <h1 class="author">Go笔记4-Go面向对象编程1</h1>
    <h5 class="subtitle">2016-05-24</h5>
  </div>
</header>

    <div class="container body-wrap">
      
  <article id="post-Go语言笔记4面向对象编程" class="article article-type-post" itemscope itemprop="blogPost">
    
      <div class="post-meat flex-row">
        <div class="flex-col">
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Go/">Go</a></li></ul>
</div>
      </div>
      <div class="post-body">

        <aside class="post-widget" id="post-widget">

          
          <div class="post-share" id="post-share" data-title="Go笔记4-Go面向对象编程1" data-pic="/img/logo.jpg" data-summary="&lt;h2 id=&quot;面向对象的特性&quot;&gt;&lt;a href=&quot;#面向对象的特性&quot; class=&quot;headerlink&quot; title=&quot;面向对象的特性&quot;&gt;&lt;/a&gt;面向对象的特性&lt;/h2&gt;&lt;p&gt;提到面向对象，我们第一反应会想到C++，Java，Python，C#一众语言。在学习时我们&lt;br&gt;也会多多少少地去类比这些传统OOP语言。Go语言相较之下设计非常简洁而又优雅。它在&lt;br&gt;语言层面上做了巨大的革新，放弃了传统OOP当中耳熟能详的概念，比如继承、虚函数、&lt;br&gt;构造函数、析构函数、隐藏this指针等。整个类型系统通过接口自动变形来串联起来，&lt;br&gt;更加简洁。这也可以侧面看出来为什么称Go是”更好的C语言”&lt;/p&gt;" data-url="http://yoursite.com/2016/05/24/Go语言笔记4面向对象编程/index.html">
    <div class="tit">分享到：</div>
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" href="javascript:;" data-title="微博" data-service="tsina">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns" href="javascript:;" data-title="微信" data-service="weixin">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" href="javascript:;" data-title=" QQ" data-service="cqq">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" href="javascript:;" data-title=" Facebook" data-service="fb">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" href="javascript:;" data-title=" Twitter" data-service="twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="douban share-sns" href="javascript:;" data-title="豆瓣" data-service="douban">
          豆
        </a>
      </li>
    </ul>
 </div>

          

          
          <nav class="post-toc-wrap" id="post-toc">
            <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#面向对象的特性"><span class="post-toc-text">面向对象的特性</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#类型系统"><span class="post-toc-text">类型系统</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#方法和函数"><span class="post-toc-text">方法和函数</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#方法的简介"><span class="post-toc-text">方法的简介</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#包"><span class="post-toc-text">包</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#访问控制和标识符"><span class="post-toc-text">访问控制和标识符</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#值类型和引用类型"><span class="post-toc-text">值类型和引用类型</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#结构体"><span class="post-toc-text">结构体</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#组合"><span class="post-toc-text">组合</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#接口"><span class="post-toc-text">接口</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Go非侵入式接口"><span class="post-toc-text">Go非侵入式接口</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#接口赋值"><span class="post-toc-text">接口赋值</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#类型判断"><span class="post-toc-text">类型判断</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#接口组合"><span class="post-toc-text">接口组合</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Any类型"><span class="post-toc-text">Any类型</span></a></li></ol>
          </nav>
          
        </aside>

        <div class="post-main">

            <div class="post-content" itemprop="postContent"><h2 id="面向对象的特性"><a href="#面向对象的特性" class="headerlink" title="面向对象的特性"></a>面向对象的特性</h2><p>提到面向对象，我们第一反应会想到C++，Java，Python，C#一众语言。在学习时我们<br>也会多多少少地去类比这些传统OOP语言。Go语言相较之下设计非常简洁而又优雅。它在<br>语言层面上做了巨大的革新，放弃了传统OOP当中耳熟能详的概念，比如继承、虚函数、<br>构造函数、析构函数、隐藏this指针等。整个类型系统通过接口自动变形来串联起来，<br>更加简洁。这也可以侧面看出来为什么称Go是”更好的C语言”</p>
<a id="more"></a>
<h2 id="类型系统"><a href="#类型系统" class="headerlink" title="类型系统"></a>类型系统</h2><p>Go语言编程一书当中说道：</p>
<p>一个典型的类型系统通常包含如下基本内容：</p>
<ul>
<li>基础类型，如byte、 int、 bool、 float等；</li>
<li>复合类型，如数组、结构体、指针等；</li>
<li>可以指向任意对象的类型（Any类型）；</li>
<li>值语义和引用语义；</li>
<li>面向对象，即所有具备面向对象特征（比如成员方法）的类型；</li>
<li>接口</li>
</ul>
<p>并且拿了Java作为讲解类型系统的范例，介绍了一下Java的两种类型系统，这里将不再比较赘述。</p>
<p>然而Go语言当中有一个十分灵巧的特性，任何类型都可以“增加”新方法。多数类型为值类型；实现接口时，是基于实现接口的模型（函数实现），而不是定义的接口所在包或者名称（这一点Java就做的比较死板），实现接口也不是继承方式，而是函数模型实现。任何类型都可以由Any类型引用。Any类型就是空接口，也就是interface{}。</p>
<h2 id="方法和函数"><a href="#方法和函数" class="headerlink" title="方法和函数"></a>方法和函数</h2><p>在对Go面向对象类型系统学习之前，我们还要对另外一个概念“方法”进行学习。<br>在学习Go语言过程中，我也逐渐发现了《Go 语言编程》一书对Go语言的诠释从函<br>数这一部分开始就有所缺失，诠释不完善。比如方法这个概念，多返回值的命名这<br>一概念，仅仅在示例中一笔带过，没有进一步进行讨论。除此以外，缺失了包的概念<br>以及对类型定义形式的最起码的解释。<br>因此后面我将会对比多部书籍进行Go语言后面部分的学习。<br>这一节为将缺失的环节进行补充。</p>
<h2 id="方法的简介"><a href="#方法的简介" class="headerlink" title="方法的简介"></a>方法的简介</h2><p>首先我会简单介绍一下方法的形式，后面我们在学习Go语言的结构体类型、接口的时候会重点学习，本节将会认识一下方法的形式还有方法和函数的区别。</p>
<p>学过Java和C++的人都知道，OOP语言当中针对一个对象可以为对象本身写一个与它相关的行为，<br>这叫做方法(C++中仍然叫做函数，不过是类当中的函数)，它与函数的区别是，一个函数是一个<br>计算规则的最小单位，它本身没有属主，是一个独立存在的计算规则单位。比如各种初等数学函数，<br>他们仅仅与规则相关，而没有任何所属物。在C++当中，函数可以独立存在，也可以成为一个类<br>的所属函数，也就成了方法，只是在C++中，他依然叫做函数。在Java中，没有函数这一概念，<br>或者说，所有的函数都是有属主的，这些函数就成了方法。要想定义与主人无关的函数，那这个方法<br>就“挂靠”在一个类下面，但是定义为静态方法，这就成了与上下文与属主无关的纯函数。</p>
<p>上面这段话啰嗦来啰嗦去，有用吗？有。Go语言提供了一个机会让“函数”和“方法”和平共处，并且共处地十分和谐，还能一目了然他们的关系。<br>在《学习Go语言》一书中，没有像我这样啰嗦了这么一大段来说明函数和方法的关系，而是用了一句<br>话 直截了当地概括了他们的关系。</p>
<pre><code>方法就是有接收者的函数。
</code></pre><p>我们简单来看一下函数签名是什么样：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Integer <span class="keyword">int</span>  <span class="comment">//这是一个简单的类型的定义，后面会说到，暂时这么一看</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> plus(x Integer, y Integer) Integer &#123;</span><br><span class="line">	<span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这是纯函数的做法,也就是一个C语言式的做法。</p>
<p>如果我为Integer这个新的类型添加一个方法来做呢？让它变得更加面向对象，也就是“方法”的做法也就是如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Integer <span class="keyword">int</span></span><br><span class="line"><span class="keyword">func</span> (x Integer) plus(y Integer) Integer &#123;</span><br><span class="line">	<span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们可以看到，方法比函数多了一点东西，<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> (x Integer) plus(y Integer) Integer</span><br></pre></td></tr></table></figure></p>
<p><strong>在关键字func和方法名中间用括号将x Integer括起来，x Integer在这里，不但是函数参数，而且还是这个方法的所属类型，这样一来，在Java、C++、C#中的隐藏指针this就被显性的当作参数名来使用，简洁明了，设计非常之巧妙，还将方法和函数在同一个语言中和谐的并存。</strong></p>
<p>我们定义了一个Integer类型，并为这个类型添加了与这个类型相关联的方法，这个“方法”就可以操作这个类型。就像C++一样。</p>
<p>以上的函数和方法的例子，可以写在用一个源文件里，写一个main函数，并输出测试一下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">	fmt.Println(plus(<span class="number">1</span>, <span class="number">6</span>))</span><br><span class="line">	<span class="keyword">var</span> a Integer = <span class="number">3</span></span><br><span class="line">	fmt.Println(a.plus(<span class="number">7</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Integer <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> plus(x Integer, y Integer) Integer &#123;</span><br><span class="line">	<span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> (x Integer) plus(y Integer) Integer &#123;</span><br><span class="line">	<span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段测试也如我们意料那样，输出</p>
<pre><code>7
10
</code></pre><p>这一节当中实际上搀和了一些新的概念，比如定义类型。实际上这里还有一个值传递或引用传递的问题，会在以后的章节中再讨论。</p>
<h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><p>关于包这个问题，在《Go语言编程》一书中前几章连提都没有提(翻了一下后面也没有找到)，对于学<br>习者来说这是语言类书籍作者的重大失误。</p>
<p>我们来看包的概念和使用。</p>
<p>包是函数和数据的集合。我们用package关键字定义一个包。文件名不需要与包名一致，在定义包名时，是使用小写字符。Go的包可以由多个文件组成，只要使用相同的package [name]这一行。</p>
<p>并且在编译时，要让你定义的包都存于你当前的\$GOPATH中，以确保Go编译器能够在\$GOPATH路径变量中寻找到这个包。</p>
<p>关于包，还有一个很重要的规则约定。import语句在导入包时，实际上是导入包的路径。详细一点来说，当我<br>们导入一个包(这个名称可能是一个路径)，例如fmt包，我们会写作import “fmt”，实际上Go的编译器会去<br>到<strong>\$GOPATH/src</strong>目录下去寻找fmt目录，从而在这个目录下的所有同包名(package 后面名称相同)的<br>go文件去寻找引用的标识符。如果找不到，则会抛出undefined符号错误。如果是在<strong>\$GOPATH/src</strong>目<br>录中的更次级目录，那就需要有目录分隔符分割目录名。</p>
<p>在使用这个包当中的内容时，要使用package中定义的内容定义的包名，而不是路径名。<br>我们可以进行一个最佳实践去学习这几个麻烦的包访问规则。我们在上面练习了两数相加的范例，<br>依然使用这个范例来演示。</p>
<p>首先我们在某一个\$GOPATH/src下新创建一个mymath目录，在mymath目录中创建一个simple目录，在simple目录中创建一个math.go文件，把我们上面的练习代码复制进来并且保存，并写对包名。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mymath project mymath.go</span></span><br><span class="line"><span class="keyword">package</span> mymath</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Integer <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> Plus(x Integer, y Integer) Integer &#123;</span><br><span class="line">	<span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> (x Integer) Plus(y Integer) Integer &#123;</span><br><span class="line">	<span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如此一来，我们已经创建好了一个简单的包，名叫mymath。</p>
<p>我们在LiteIDE中创建一个新的项目和GO文件(要保证LiteIDE和GO编译器能正确访问到\$GOPATH变量)<br>并写以下测试代码：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Syntax project main.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"mymath/simple"</span>	  <span class="comment">//我们可以看到，引入的包名实际上是相对路径</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">	fmt.Println(mymath.Plus(<span class="number">1</span>, <span class="number">6</span>))		<span class="comment">//在使用时依然是使用package mymath定义的包名mymath定义的包名</span></span><br><span class="line">	<span class="keyword">var</span> a mymath.Integer = <span class="number">3</span></span><br><span class="line">	fmt.Println(a.Plus(<span class="number">7</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>另外，如果一些包的包名起名字起的太奇怪，或者太长或者…… 反正不喜欢，或者不能表达这个包的作用时，还可以为这个包名起一个临时的别名。用法是</p>
<pre><code>import [alias] &quot;mymath/simple&quot;
</code></pre><p>如果是多个导入包？见代码：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Syntax project main.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	p <span class="string">"fmt"</span></span><br><span class="line">	m <span class="string">"mymath/simple"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">	p.Println(m.Plus(<span class="number">1</span>, <span class="number">6</span>))</span><br><span class="line">	<span class="keyword">var</span> a m.Integer = <span class="number">3</span></span><br><span class="line">	p.Println(a.Plus(<span class="number">7</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这两个导入包分别用一个简单的名字代替了,为了体现简单所以我用一个字母代替了，未成年人请勿模仿。</p>
<h2 id="访问控制和标识符"><a href="#访问控制和标识符" class="headerlink" title="访问控制和标识符"></a>访问控制和标识符</h2><p>Go的命名是有特定的约定的，这个约定直接影响着代码的逻辑。</p>
<ul>
<li>在一个包内的函数名类型名等命名影响是否可以导出到其他包使用，这取决于这个名称开头是</li>
<li>否为大写，只有大写的命名才允许导出到其它包中使用。</li>
<li>这意味着在其他的包当中，如果你的包有一个函数名或者类型名开头是小写，那么你就相当于</li>
<li>为这个函数或者类型设定为private，不允许包外使用。</li>
</ul>
<h2 id="值类型和引用类型"><a href="#值类型和引用类型" class="headerlink" title="值类型和引用类型"></a>值类型和引用类型</h2><p>Go语言中大多数类型都基于值类型<br>其中包括：</p>
<ul>
<li>基本类型：如byte, int, bool, float32, float64和string等。</li>
<li>复合类型：如数组(array)、结构体(struct)和指针(pointer)等。</li>
</ul>
<p>其中数组类型更加特别一些，它的行为与我们所了解的C系语言不一样。C的数组变量的变量名为首位指针，<br>作为数组引用，因此数组变量赋值给其他变量时，实际上传递的是数组(或者某位置上的)的引用。数组还是<br>那个数组，内存位置还是那个位置。而Go不一样，赋值时是将值完全复制。<br>光说不练假把式，写个例子来直观表现一下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">	<span class="comment">//定义一个数组</span></span><br><span class="line">	<span class="keyword">var</span> a = [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    <span class="comment">//然后赋值</span></span><br><span class="line">	<span class="keyword">var</span> b = a</span><br><span class="line">	<span class="comment">//为其中一个元素重新赋值</span></span><br><span class="line">	b[<span class="number">1</span>] = <span class="number">100</span></span><br><span class="line">    <span class="comment">//结果是影响了一个数组还是两个数组呢？</span></span><br><span class="line">	fmt.Println(a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们拿来看一下结果：</p>
<pre><code>[1 2 3] [1 100 3]
</code></pre><p>很明显，Go中的数组赋值实际上是完整复制，而不是引用赋值。</p>
<p>当然，要实现C语言的引用赋值也不是麻烦事。Go当中也有取引用符”&amp;”和指针变量符”*”<br>比如：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="comment">//通过取a的引用地址，此时b变量为指针变量，引用a</span></span><br><span class="line"><span class="keyword">var</span> b = &amp;a</span><br><span class="line"></span><br><span class="line">b[<span class="number">1</span>] = <span class="number">100</span></span><br><span class="line"><span class="comment">//打印时，\*b将指针变量引向正确的数据区，打印数组</span></span><br><span class="line">fmt.Println(a, *b)</span><br></pre></td></tr></table></figure></p>
<p>执行结果为</p>
<pre><code>[1 100 3] [1 100 3]
</code></pre><p>注意：</p>
<pre><code>这里看到代码汇总有一句跟上面范例当中一样了不？
对，就是b[1] = 100，
变量b的类型不是[3]int，而是*[3]int类型
下面这一句fmt.Println(a, *b)就用了*b，是作为指针变量去解引用使用数组值。
那么实际上这里也应当用(*b)[1]指针指向数组的形式来解析b的引用，但是使用b[1]
运行也是对的，我也不知道为什么b[1]直接使用也是对的，不知道什么原理。
难不成是语法糖？
</code></pre><p>Go除了数组外，还有数组切片，map，channel(goroutine)通信量，和interface，他们看起来像是引用类型，<br>但是他们实际上都是值类型。map和channel本身就是指针，因此他们赋值时复制指针而不是数据内容，因此他们依然<br>是值类型。这一点是跟C、C++、Java、C#是有相同点的，但是依然要小心使用。另外，接口、结构体、指针等话题后<br>面还会更多的提到。</p>
<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><p>Go的结构体可以看作跟C语言结构体差不多的东西。但是结构体不是类，Go语言当中也没有类这个概念，所以可以看出来，Go语言并不是真正的面向对象语言。然而实现并不是必须有类和对象的概念才能做面向对象编程。在Go中，一切引用类型之间的关系只有组合关系，没有继承关系。<br>定义一个结构体类型也是非常简单的<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Rect <span class="keyword">struct</span> &#123;</span><br><span class="line">	x, y          <span class="keyword">float64</span></span><br><span class="line">	width, height <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>并且为Rect这个类型“附着”一个方法：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> (r *Rect) Area() <span class="keyword">float64</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> r.width * r.height</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>初始化的方式也有好几种：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">	rect1 := <span class="built_in">new</span>(Rect)</span><br><span class="line">	rect2 := &amp;Rect&#123;&#125;</span><br><span class="line">	rect3 := &amp;Rect&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>, <span class="number">300</span>&#125;</span><br><span class="line">	rect4 := &amp;Rect&#123;width: <span class="number">200</span>, height: <span class="number">300</span>, x: <span class="number">100</span>, y: <span class="number">100</span>&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(*rect1)</span><br><span class="line">	fmt.Println(*rect2)</span><br><span class="line">	fmt.Println(*rect3, (*rect3).Area())</span><br><span class="line">	fmt.Println(*rect4, rect4.Area())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果为：</p>
<pre><code>{0 0 0 0}
{0 0 0 0}
{0 0 200 300} 60000
{100 100 200 300} 60000
</code></pre><p>因为不是面向对象语言，所以没有构造函数，我们甚至可以“捏造”一个构造函数：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> NewRect(x, y, width, height <span class="keyword">float64</span>) *Rect &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;Rect&#123;x, y, width, height&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>那么上面就多了一种初始化方式：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rect5 := NewRect(<span class="number">1</span>, <span class="number">2</span>, <span class="number">200</span>, <span class="number">300</span>)</span><br></pre></td></tr></table></figure></p>
<h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h2><p>Go的组合很有意思，组合可以实现类似面向对象语言的继承特性。（注意，这里是重头戏）<br>一个结构体类型在另一个结构体类型中作为一个成员的的时候，使用外层的结构体可以直<br>接暴露并直接访问使用内部结构体的所有导出的方法和成员变量。<br>什么意思呢？<br>我们来写一下代码：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首先先写一个基础结构体</span></span><br><span class="line"><span class="keyword">type</span> Base <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为这个结构体附加方法：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> (base *Base) ComputeLen() &#123;</span><br><span class="line">	fmt.Println(<span class="string">"base"</span>, <span class="built_in">len</span>(base.Name))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在我们有了一个有方法的结构体了，然后再写一个组合的结构体：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> House <span class="keyword">struct</span> &#123;</span><br><span class="line">	Base</span><br><span class="line">	Layers <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>直接把Base作为一个成员写进这个结构体，此时这个House结构体相当于组合了Base，它拥有了Base的方法和成员变量。<br>也就是说，原本我们要访问ComputeLen方法，本来应该这么访问<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">h := House&#123;Layers: <span class="number">30</span>&#125;</span><br><span class="line">h.Base.ComputeLen()</span><br></pre></td></tr></table></figure></p>
<p>其实也可以直接访问：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">h := House&#123;Layers: <span class="number">30</span>&#125;</span><br><span class="line">h.ComputeLen()</span><br></pre></td></tr></table></figure></p>
<p>这就是Go语言通过组合的方式提供了“继承”的功能。不但有“继承”，还可以重写方法，比如当前这个例子，我们重写ComputeLen方法：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> (house *House) ComputeLen() &#123;</span><br><span class="line">	house.Base.ComputeLen()</span><br><span class="line">	fmt.Println(<span class="string">"house"</span>, <span class="built_in">len</span>(house.Name)+house.Layers)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此时，h.ComputeLen()调用的方法就不是h.Base.ComputeLen()方法了，而是重写<br>过的方法，而重写过程中访问组合来的方法，还是通过h.Base.ComputeLen()来调用。<br>如此一来，省掉了Java、C++使用的this指针和super关键字，还让组合的结构体之间<br>的关系十分透明而优雅。<br>另外，指针成员方式也可以提供继承。不过需要外部赋予一个实例的指针。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> House <span class="keyword">struct</span> &#123;</span><br><span class="line">	*Base</span><br><span class="line">	Layers <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果组合的结构体之间遇到同名的成员，内部的成员仍然还是作为间接的访问访问到的，而直接访问仍然是外部的成员。</p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>虽然关键字和Java的接口一样，而且定义很相像，但是这个接口不同于Java的接口，它不是需要强制实现的，而是契约式实现的，或者说是具体实现的一个“投影”。Java、C#的接口，C++的纯虚类，都是这种强制实现的接口。这种接口在我开发Android应用时就已经十分清楚这种痛苦。要使用接口，那可能是我在需要有解除高度耦合的代码，并且设计可替换模块的时候，或者设计多种行为策略的时候，需要高度的远见性，才能设计出可能将来会持续合理的接口。甚至有时会因为相同的行为定义很多重复角色的接口，但是必须要在不同的包下，有时有些可能完全可以互通的行为，解耦之后需要编写桥接类或者适配器类才能使用对方，这就造成了Java或者C#这类语言在编写业务时，因为模式带来的大量的冗余。因此，Java、C#等语言的接口被称作是“侵入式”的。</p>
<h2 id="Go非侵入式接口"><a href="#Go非侵入式接口" class="headerlink" title="Go非侵入式接口"></a>Go非侵入式接口</h2><p>在Go语言中，一个类只要实现了接口要求的所有函数，我们就说这个类实现了该接口，而不需要去显式地使用implement或者:等符号告知编译器实现某接口。Go的接口实现为接口制造的是“投影”，而不是“行为模型”。因此也不用去考虑绘制像Java那样的巨大的类、接口继承树图，而是一种更扁平的思考方式。因此在实现类的时候，不用再费心考虑接口如何拆分方法更合理。接口就可以按照使用来造型，而不用费尽心思像算命一样去预测未来地那样规划。除此以外，自由的定义接口还可以降低包之间的耦合度，只要”投影相同”，就可以使用。</p>
<p>说了这么多，接口怎么用呢？<br>看一个例子就知道了<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.先定义具体的结构</span></span><br><span class="line"><span class="keyword">type</span> Bike <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//添加方法</span></span><br><span class="line"><span class="keyword">func</span> (b *Bike) Run() &#123;</span><br><span class="line">	fmt.Println(b.Name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义接口</span></span><br><span class="line"><span class="keyword">type</span> Brand <span class="keyword">interface</span> &#123;</span><br><span class="line">	Run()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">	<span class="keyword">var</span> bike Bike = Bike&#123;Name: <span class="string">"Gakki"</span>&#125;</span><br><span class="line">	bike.Run()</span><br><span class="line">    <span class="comment">//那么只要接口的方法都已经完全被结构体所实现，那么这个接口无论什么名称，还是在哪个包下，那么它的是一定被实现的，所以结构体的实例可以被直接“造型”为接口实例</span></span><br><span class="line">	<span class="keyword">var</span> br Brand = <span class="built_in">new</span>(Bike)</span><br><span class="line">	br.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="接口赋值"><a href="#接口赋值" class="headerlink" title="接口赋值"></a>接口赋值</h2><p>赋值有两种情况：</p>
<ul>
<li>将对象实例赋值给接口</li>
<li>将一个接口赋值给另一个接口</li>
</ul>
<p>我们看一个例子：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">	<span class="keyword">var</span> a Integer = <span class="number">1</span></span><br><span class="line">	<span class="keyword">var</span> b LessAdder = a</span><br><span class="line">	fmt.Println(<span class="string">"Hello :"</span>, b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Integer <span class="keyword">int</span></span><br><span class="line"><span class="comment">//实现了LessAdder的两个方法</span></span><br><span class="line"><span class="keyword">func</span> (a Integer) Less(b Integer) <span class="keyword">bool</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> a &lt; b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> (a Integer) Add(b Integer) &#123;</span><br><span class="line">	a += b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> LessAdder <span class="keyword">interface</span> &#123;</span><br><span class="line">	Less(b Integer) <span class="keyword">bool</span></span><br><span class="line">	Add(b Integer)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>注意：这里方法的所属结构(a Integer)不能含有指针，具体为什么，尚且不清楚。
《Go语言编程》一书当中，出现了
func (a *Integer) Add(b Integer) {
    *a += b
}
这种形式，但是我在Go 1.6.2的经过测试，这种形式已经不能使用了。
否则会报告如下错误：
cannot use a (type Integer) as type LessAdder in assignment:
Integer does not implement LessAdder (Add method has pointer receiver)
</code></pre><p>在上一节的范例中，有一个结构体是<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Bike <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个结构体有一个方法：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> (b Bike) Run() &#123;</span><br><span class="line">	fmt.Println(b.Name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>它和<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> (b *Bike) Run() &#123;</span><br><span class="line">	fmt.Println((*b).Name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>甚至<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> (b *Bike) Run() &#123;</span><br><span class="line">	fmt.Println(b.Name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这三种方式都是等同的。</p>
<p>Bike结构的Run()方法，这三种形式编译运行是等同的效果。</p>
<p>但是！请注意：</p>
<p>如果我们需要用<strong>switch (type)</strong>来对对象进行实例类型判断，就只能用</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> (b Bike) Run() &#123;</span><br><span class="line">	fmt.Println(b.Name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式再对实现了接口的类型进行判断，否则会编译失败。</p>
<h2 id="类型判断"><a href="#类型判断" class="headerlink" title="类型判断"></a>类型判断</h2><p>比如我们把上面的例子进行如下修改：(为了便于阅读，特意修改了一下顺序)<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Brand <span class="keyword">interface</span> &#123;</span><br><span class="line">	Run()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Bike <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这个方法，就不能在方法属主上包含有指针了，(b *Bike)就是错误的</span></span><br><span class="line"><span class="keyword">func</span> (b Bike) Run() &#123;</span><br><span class="line">	fmt.Println(b.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">	<span class="keyword">var</span> bike Brand = Bike&#123;Name: <span class="string">"Gakki"</span>&#125;</span><br><span class="line">    <span class="comment">//通过.(type)语法对实例进行判断。不过可惜，现在只能用switch</span></span><br><span class="line">	<span class="keyword">switch</span> c := bike.(<span class="keyword">type</span>) &#123;</span><br><span class="line">	<span class="keyword">case</span> Brand:</span><br><span class="line">		fmt.Println(<span class="string">"Brand 类型"</span>, c)</span><br><span class="line">		c.Run()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>switch [实例].(type)只能以switch配合type使用，这一点并不如java中的instanceof关键字返回布尔类型更灵活。</p>
<h2 id="接口组合"><a href="#接口组合" class="headerlink" title="接口组合"></a>接口组合</h2><p>接口和结构体一样，也可以进行组合，而且也有相同的组合特点。<br>前面介绍结构体的时候已经介绍过，我们现在修改上面的例子来体现：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interface project main.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyAge <span class="keyword">interface</span> &#123;</span><br><span class="line">	ShowAge()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Brand <span class="keyword">interface</span> &#123;</span><br><span class="line">	Run()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> BrandAndAge <span class="keyword">interface</span> &#123;</span><br><span class="line">	MyAge</span><br><span class="line">	Brand</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Bike <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">	Age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> (b Bike) Run() &#123;</span><br><span class="line">	fmt.Println(b.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> (b Bike) ShowAge() &#123;</span><br><span class="line">	fmt.Println(b.Age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">	<span class="keyword">var</span> bike Brand = Bike&#123;Name: <span class="string">"Gakki"</span>, Age: <span class="number">7</span>&#125;</span><br><span class="line">	<span class="keyword">switch</span> c := bike.(<span class="keyword">type</span>) &#123;</span><br><span class="line">	<span class="keyword">case</span> BrandAndAge:</span><br><span class="line">		fmt.Println(<span class="string">"BrandAndAge 类型"</span>, c)</span><br><span class="line">		c.Run()</span><br><span class="line">		c.ShowAge()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后的执行结果为：</p>
<pre><code>BrandAndAge 类型 {Gakki 7}
Gakki
7
</code></pre><h2 id="Any类型"><a href="#Any类型" class="headerlink" title="Any类型"></a>Any类型</h2><p>类似于Java中的Object类型，Go中有一个interface{}作为任意类型的名称。可以在类型定义中使用，也可以<br>在传参时使用。<br>比如刚刚看过去的上面的那个例子，var bike Brand = …<br>就可以修改为：var bike interface{} = Bike{Name: “Gakki”, Age: 7}<br>后面可以通过类型判断了解到这个实例有什么行为方法可以使用。作为函数参数时，还可以作为任意类型传入。<br>比C语言中的(void *)表示要好得多。C语言中因为void是无类型，但是无类型指针却表示的是任意类型，且可以造型为任意类型。这着实让人蛋疼了一把。</p>
<p>面向对象的特性先介绍到这里。我们可以看到，Go语言的类型系统的基本特性，实际上就一种特性：组合。<br>接口的特性其实也只有两种：组合和“造影实现”。“造影实现”这个词是我编的，因为Go语言完全不需要你预先设计<br>接口并且让一个类去实现，而是实现和接口设计完全分离，他们之间的关联关系仅仅是方法的模型一致，<br>即实现了方法。这一点上，他的思想要比Java和复杂的C++的虚类型系统简直好太多，因为在Java和C++中，<br>开发者需要有深厚的技术经验和业务经验来“算命”，“算”好了接口去设计，然而Go中并不这么做。Go在这一点点可<br>以“无为而治”之。接口真正成为一个结构体的“影子”，而不是像Java那样的“帽子”,Java对象没有这个“帽子”，实现了接口的行为，接口也不会承认。</p>
<p>下一次将开始更加重头的重头戏，Go语言的并发编程</p>
</div>

            
<nav class="post-nav flex-row">
  <div class="flex-col waves-block prev">
    
      <a href="/2016/06/03/Go语言笔记5/" title="Go笔记5-Go并发编程" id="post-prev" class="post-nav-link">
        <i class="icon icon-chevron-left"></i>
        <span class="article-nav-title">上一篇</span>
      </a>
    
  </div>
  <div class="flex-col waves-block next">
    
      <a href="/2016/05/21/Spring学习16~18/" title="Spring学习16-18节 AOP" id="post-next" class="post-nav-link">
        <span class="article-nav-title">下一篇</span>
        <i class="icon icon-chevron-right"></i>
      </a>
    
  </div>

</nav>



            




        </div>

      </div>

    

  </article>



    </div>
  </main>
<div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-circle-light"><span class="icon icon-lg icon-chevron-up"></span></a>
<div class="global-share" id="global-share" data-title="Go笔记4-Go面向对象编程1" data-pic="/img/logo.jpg" data-summary="&lt;h2 id=&quot;面向对象的特性&quot;&gt;&lt;a href=&quot;#面向对象的特性&quot; class=&quot;headerlink&quot; title=&quot;面向对象的特性&quot;&gt;&lt;/a&gt;面向对象的特性&lt;/h2&gt;&lt;p&gt;提到面向对象，我们第一反应会想到C++，Java，Python，C#一众语言。在学习时我们&lt;br&gt;也会多多少少地去类比这些传统OOP语言。Go语言相较之下设计非常简洁而又优雅。它在&lt;br&gt;语言层面上做了巨大的革新，放弃了传统OOP当中耳熟能详的概念，比如继承、虚函数、&lt;br&gt;构造函数、析构函数、隐藏this指针等。整个类型系统通过接口自动变形来串联起来，&lt;br&gt;更加简洁。这也可以侧面看出来为什么称Go是”更好的C语言”&lt;/p&gt;" data-url="http://yoursite.com/2016/05/24/Go语言笔记4面向对象编程/index.html">
    <div class="tit">分享到：</div>
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" href="javascript:;" data-title="微博" data-service="tsina">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns" href="javascript:;" data-title="微信" data-service="weixin">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" href="javascript:;" data-title=" QQ" data-service="cqq">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" href="javascript:;" data-title=" Facebook" data-service="fb">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" href="javascript:;" data-title=" Twitter" data-service="twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="douban share-sns" href="javascript:;" data-title="豆瓣" data-service="douban">
          豆
        </a>
      </li>
    </ul>
 </div>


<script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>

<script src="/js/main.js"></script>








</body>
</html>
